<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Satellite Tracker with Joystick</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #0f0;
      user-select: none;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 8px;
      max-width: 300px;
      font-size: 14px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="info">Use arrow keys or joystick to move antenna cursor.<br>Satellite info will show here when locked on.</div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // --- Setup scene, camera, renderer ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 30);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Earth sphere
    const earthRadius = 10;
    const earthGeometry = new THREE.SphereGeometry(earthRadius, 64, 64);
    const earthMaterial = new THREE.MeshPhongMaterial({
      map: new THREE.TextureLoader().load('https://cdn.jsdelivr.net/npm/three-globe/example/img/earth-day.jpg'),
      specular: 0x333333,
      shininess: 15
    });
    const earth = new THREE.Mesh(earthGeometry, earthMaterial);
    scene.add(earth);

    // Light
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5,10,7);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x222222));

    // Controls for camera orbiting
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableZoom = true;

    // Antenna cursor - small glowing sphere on earth surface
    const cursorGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    const cursorMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00, emissive: 0x00ff00});
    const antennaCursor = new THREE.Mesh(cursorGeometry, cursorMaterial);
    scene.add(antennaCursor);

    // Initial cursor spherical coordinates (lat, lon)
    let cursorLat = 0;  // degrees
    let cursorLon = 0;  // degrees

    // Function to convert lat/lon to 3D position on sphere surface
    function latLonToVector3(lat, lon, radius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lon + 180) * (Math.PI / 180);

      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);

      return new THREE.Vector3(x, y, z);
    }

    function updateCursorPosition() {
      antennaCursor.position.copy(latLonToVector3(cursorLat, cursorLon, earthRadius + 0.5));
    }

    updateCursorPosition();

    // Satellite data example (simulated or real fetched later)
    // For demo, a few satellites with positions in lat/lon
    // In real app, fetch live data from N2YO or other APIs
    const satellites = [
      {name: "ISS (ZARYA)", lat: 10, lon: 20},
      {name: "Hubble Space Telescope", lat: -15, lon: 45},
      {name: "NOAA 15", lat: 60, lon: -70},
      {name: "Starlink 1500", lat: 30, lon: 120}
    ];

    // Create satellite markers
    const satGeometry = new THREE.SphereGeometry(0.25, 12, 12);
    const satMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
    satellites.forEach(sat => {
      sat.mesh = new THREE.Mesh(satGeometry, satMaterial);
      sat.mesh.position.copy(latLonToVector3(sat.lat, sat.lon, earthRadius + 2));
      scene.add(sat.mesh);
    });

    // Info display div
    const infoDiv = document.getElementById('info');

    // Function to find satellite closest to cursor within threshold
    function findClosestSatellite(lat, lon, thresholdDeg = 10) {
      let closest = null;
      let minDist = thresholdDeg;
      satellites.forEach(sat => {
        const dLat = sat.lat - lat;
        const dLon = sat.lon - lon;
        // Approx distance in degrees
        const dist = Math.sqrt(dLat*dLat + dLon*dLon);
        if(dist < minDist){
          minDist = dist;
          closest = sat;
        }
      });
      return closest;
    }

    // Joystick simulation with arrow keys for now
    window.addEventListener('keydown', (e) => {
      const step = 2; // degrees per press
      switch(e.key) {
        case 'ArrowUp': cursorLat = Math.min(cursorLat + step, 90); break;
        case 'ArrowDown': cursorLat = Math.max(cursorLat - step, -90); break;
        case 'ArrowLeft': cursorLon = (cursorLon - step + 180) % 360 - 180; break;
        case 'ArrowRight': cursorLon = (cursorLon + step + 180) % 360 - 180; break;
      }
      updateCursorPosition();
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Optional: slowly rotate Earth for cool effect
      earth.rotation.y += 0.0005;

      // Highlight satellite if close to antenna cursor
      satellites.forEach(sat => {
        sat.mesh.material.color.set(0xff0000);
        sat.mesh.scale.set(1,1,1);
      });

      const lockedSat = findClosestSatellite(cursorLat, cursorLon);
      if(lockedSat) {
        lockedSat.mesh.material.color.set(0x00ff00);
        lockedSat.mesh.scale.set(1.5,1.5,1.5);
        infoDiv.innerHTML = `
          <b>Tracking Satellite:</b><br>
          Name: ${lockedSat.name}<br>
          Latitude: ${lockedSat.lat.toFixed(2)}°<br>
          Longitude: ${lockedSat.lon.toFixed(2)}°
        `;
      } else {
        infoDiv.innerHTML = `Use arrow keys or joystick to move antenna cursor.<br>Satellite info will show here when locked on.`;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
