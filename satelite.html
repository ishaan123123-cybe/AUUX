<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Satellite Tracker with Joystick</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #0f0;
      user-select: none;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 8px;
      max-width: 300px;
      font-size: 14px;
      pointer-events: none;
    }
    #connectJoystickBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 10px 15px;
      background: rgba(0,255,0,0.15);
      border: 1px solid #0f0;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      color: #0f0;
      user-select: none;
      z-index: 10;
      transition: background 0.3s;
    }
    #connectJoystickBtn:hover {
      background: rgba(0,255,0,0.4);
    }
  </style>
</head>
<body>
  <div id="info">Use arrow keys or joystick to move antenna cursor.<br>Satellite info will show here when locked on.</div>
  <button id="connectJoystickBtn">Connect Joystick</button>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // --- Setup scene, camera, renderer ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 30);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Earth sphere
    const earthRadius = 10;
    const earthGeometry = new THREE.SphereGeometry(earthRadius, 64, 64);
    const earthMaterial = new THREE.MeshPhongMaterial({
      map: new THREE.TextureLoader().load('https://cdn.jsdelivr.net/npm/three-globe/example/img/earth-day.jpg'),
      specular: 0x333333,
      shininess: 15
    });
    const earth = new THREE.Mesh(earthGeometry, earthMaterial);
    scene.add(earth);

    // Light
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5,10,7);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x222222));

    // Controls for camera orbiting
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableZoom = true;

    // Antenna cursor - small glowing sphere on earth surface
    const cursorGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    const cursorMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00, emissive: 0x00ff00});
    const antennaCursor = new THREE.Mesh(cursorGeometry, cursorMaterial);
    scene.add(antennaCursor);

    // Initial cursor spherical coordinates (lat, lon)
    let cursorLat = 0;  // degrees
    let cursorLon = 0;  // degrees

    // Function to convert lat/lon to 3D position on sphere surface
    function latLonToVector3(lat, lon, radius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lon + 180) * (Math.PI / 180);

      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);

      return new THREE.Vector3(x, y, z);
    }

    function updateCursorPosition() {
      antennaCursor.position.copy(latLonToVector3(cursorLat, cursorLon, earthRadius + 0.5));
    }

    updateCursorPosition();

    // Satellite data example (simulated or real fetched later)
    const satellites = [
      {name: "ISS (ZARYA)", lat: 10, lon: 20},
      {name: "Hubble Space Telescope", lat: -15, lon: 45},
      {name: "NOAA 15", lat: 60, lon: -70},
      {name: "Starlink 1500", lat: 30, lon: 120}
    ];

    // Create satellite markers
    const satGeometry = new THREE.SphereGeometry(0.25, 12, 12);
    const satMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
    satellites.forEach(sat => {
      sat.mesh = new THREE.Mesh(satGeometry, satMaterial);
      sat.mesh.position.copy(latLonToVector3(sat.lat, sat.lon, earthRadius + 2));
      scene.add(sat.mesh);
    });

    // Info display div
    const infoDiv = document.getElementById('info');

    // Function to find satellite closest to cursor within threshold
    function findClosestSatellite(lat, lon, thresholdDeg = 10) {
      let closest = null;
      let minDist = thresholdDeg;
      satellites.forEach(sat => {
        const dLat = sat.lat - lat;
        const dLon = sat.lon - lon;
        const dist = Math.sqrt(dLat*dLat + dLon*dLon);
        if(dist < minDist){
          minDist = dist;
          closest = sat;
        }
      });
      return closest;
    }

    // --- Keyboard controls as fallback ---
    let useJoystick = false;

    window.addEventListener('keydown', (e) => {
      if(useJoystick) return; // disable keyboard if joystick active
      const step = 2; // degrees per press
      switch(e.key) {
        case 'ArrowUp': cursorLat = Math.min(cursorLat + step, 90); break;
        case 'ArrowDown': cursorLat = Math.max(cursorLat - step, -90); break;
        case 'ArrowLeft': cursorLon = (cursorLon - step + 180) % 360 - 180; break;
        case 'ArrowRight': cursorLon = (cursorLon + step + 180) % 360 - 180; break;
      }
      updateCursorPosition();
    });

    // --- Joystick/Gamepad Integration ---
    const connectJoystickBtn = document.getElementById('connectJoystickBtn');

    connectJoystickBtn.addEventListener('click', () => {
      useJoystick = true;
      connectJoystickBtn.disabled = true;
      connectJoystickBtn.textContent = 'Joystick Connected';
      window.requestAnimationFrame(gamepadLoop);
    });

    // Deadzone helper for joystick sticks
    function applyDeadzone(value, deadzone = 0.15) {
      if (Math.abs(value) < deadzone) return 0;
      return value;
    }

    // Gamepad loop for joystick input reading
    function gamepadLoop() {
      const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
      if (!gamepads) {
        requestAnimationFrame(gamepadLoop);
        return;
      }
      for (const gp of gamepads) {
        if (!gp) continue;

        // Typically axes[0] = left stick horizontal, axes[1] = left stick vertical
        const x = applyDeadzone(gp.axes[0]);
        const y = applyDeadzone(gp.axes[1]);

        const sensitivity = 1.5; // degrees per frame moved by joystick

        if (x !== 0) {
          cursorLon = (cursorLon + x * sensitivity + 180) % 360 - 180;
        }
        if (y !== 0) {
          cursorLat = Math.min(90, Math.max(-90, cursorLat - y * sensitivity));
        }

        updateCursorPosition();
      }
      requestAnimationFrame(gamepadLoop);
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      earth.rotation.y += 0.0005;

      satellites.forEach(sat => {
        sat.mesh.material.color.set(0xff0000);
        sat.mesh.scale.set(1,1,1);
      });

      const lockedSat = findClosestSatellite(cursorLat, cursorLon);
      if(lockedSat) {
        lockedSat.mesh.material.color.set(0x00ff00);
        lockedSat.mesh.scale.set(1.5,1.5,1.5);
        infoDiv.innerHTML = `
          <b>Tracking Satellite:</b><br>
          Name: ${lockedSat.name}<br>
          Latitude: ${lockedSat.lat.toFixed(2)}°<br>
          Longitude: ${lockedSat.lon.toFixed(2)}°
        `;
      } else {
        infoDiv.innerHTML = `Use arrow keys or joystick to move antenna cursor.<br>Satellite info will show here when locked on.`;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
